---
title: "Whole-cube Bootstrap versus Group-specific Bootstrap"
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

When calculating biodiversity indicators from a cube, we often want confidence intervals (CIs) using bootstrapping. In **dubicube**, bootstrapping can be done in two ways:

* **Whole-cube bootstrapping**: resampling all rows in the cube, regardless of grouping.
* **Group-specific bootstrapping**: resampling rows only within a group of interest (e.g., a species, year, or habitat).

The choice between these two methods directly affects how confidence intervals should be interpreted:

* Other indicators **combine information across groups** (e.g., community richness, turnover, or multi-species metrics). These require whole-cube bootstrapping to preserve correlations.
* Some indicators are **calculated independently per group** (e.g., species-specific or year-specific metrics). For these, group-specific bootstrapping is usually more appropriate.

In this tutorial, we explain the differences, discuss the strengths and limitations of each method, and provide a worked example.

## Methods

Consider the `iris` example dataset. We calculate the mean sepal length and use bootstrapping for uncertainty calculation.

```{r}
mean_sepal_length <- function(x) {
  out_df <- aggregate(Sepal.Length ~ Species, x, mean)
  names(out_df) <- c("Species", "diversity_val")
  out_df
}
```

```{r}
mean_sepal_length(iris)
```

### `dubicube`'s smart method

```{r}
library(dubicube)
```

The smart option (`method = "smart"`) is the default functionality of the `bootstrap_cube()` function. With this option, **dubicube** automatically chooses the most suitable method. It does so by comparing indicator values calculated on larger versus smaller subsets of the data, checking whether the common groups yield identical results. If so, group-specific bootstrapping is applied; otherwise, whole-cube bootstrapping is used. If no reference group is used (`ref_group = NA`), the **boot** package is used for bootstrapping.

| Scope of indicator calculation | Reference group used? | Method chosen by `method = "smart"` | Uses **boot** package? |
| ------------------------------ | --------------------- | --------------------- | --- |
| Group-specific                 | No (`ref_group = NA`) | `boot_group_specific` | yes |
| Whole cube                     | No (`ref_group = NA`) | `boot_whole_cube`     | yes |
| Group-specific                 | Yes                   | `group_specific`      | no  |
| Whole cube                     | Yes                   | `whole_cube`          | no  |

In practice, users rarely need to set method explicitly: `method = "smart"` selects the appropriate strategy based on indicator behaviour and the presence of a reference group.

```{r}
bootstrap_mean_smart <- bootstrap_cube(
  data_cube = iris,
  fun = mean_sepal_length,
  grouping_var = "Species",
  samples = 1000,
  seed = 123,
  processed_cube = FALSE # We are not working with a processed cube
)
```

As expected, the **boot** package was used since no reference group was specified and we use group-specific bootstrapping since the mean sepal length is calculated separately per species.
We get a named list of `"boot"` objects (see further).

```{r}
sapply(bootstrap_mean_smart, class)
```

### Whole-cube bootstrap

**Definition:** Resample all rows in the cube, regardless of species, year, or other grouping.

**Advantages:**

* Preserves correlations between groups (e.g., species co-occurrence, temporal dependencies).
* Appropriate for indicators that depend on multiple groups together (community-level metrics, multi-species diversity).

**Disadvantages:**

* Rare groups may end up with zero rows in some bootstrap replicates, leading to wider or undefined CIs.
* Variance for small groups may be inflated.

**Use case examples:**

* Community richness per site or habitat.
* Multi-species indicators (e.g., average occupancy across species).
* Temporal turnover indicators that rely on multiple years.

**Implementation in `dubicube`**

* Use `method = "whole_cube"` in the `bootstrap_cube()` function.

```{r}
bootstrap_mean_whole <- bootstrap_cube(
  data_cube = iris,
  fun = mean_sepal_length,
  grouping_var = "Species",
  samples = 1000,
  seed = 123,
  processed_cube = FALSE,
  method = "whole_cube"
)
head(bootstrap_mean_whole)
```

### Group-specific bootstrap

**Definition:** Subset the cube by the group of interest (e.g., species or year), then resample rows only within that group.

**Advantages:**

* Guarantees each replicate has rows for the group → stable CIs.
* Reflects within-group variability only.

**Disadvantages:**

* Ignores correlations with other groups.
* Variance may be slightly underestimated if the group’s presence is correlated with other groups.

**Use case examples:**

* Species-specific occupancy or habitat preference metrics.
* Year-specific indicators (e.g., annual richness).
* Small or rare groups where zero-row replicates would be problematic.

**Implementation in `dubicube`**

* Use `method = "group_specific"` in the `bootstrap_cube()` function.

```{r}
bootstrap_mean_group <- bootstrap_cube(
  data_cube = iris,
  fun = mean_sepal_length,
  grouping_var = "Species",
  samples = 1000,
  seed = 123,
  processed_cube = FALSE,
  method = "group_specific"
)
head(bootstrap_mean_group)
```

### Bootstrapping with the **boot** package

For most use cases, **dubicube** delegates the resampling procedure to the well-established **boot** package (Canty et al., [2025](https://doi.org/10.32614/CRAN.package.boot)). This happens when:

* Automatically with `method = "smart"` (default) and no reference group is specified (default)
* Manually with `method = "boot_whole_cube"` or `method = "boot_group_specific"`

In these cases, `bootstrap_cube()` returns the native objects produced by `boot::boot()`, rather than a summarised data frame.

#### Whole-cube bootstrap with **boot**

When whole-cube bootstrapping is performed via **boot**, a single `"boot"` object is returned.

```{r}
bootstrap_mean_boot_whole <- bootstrap_cube(
  data_cube = iris,
  fun = mean_sepal_length,
  grouping_var = "Species",
  samples = 1000,
  seed = 123,
  processed_cube = FALSE,
  method = "boot_whole_cube"
)
class(bootstrap_mean_boot_whole)
```

#### Group-specific bootstrap with **boot**

For group-specific bootstrapping via **boot**, `bootstrap_cube()` returns a named list of `"boot"` objects, one per group.

```{r}
bootstrap_mean_boot_group <- bootstrap_cube(
  data_cube = iris,
  fun = mean_sepal_length,
  grouping_var = "Species",
  samples = 1000,
  seed = 123,
  processed_cube = FALSE,
  method = "boot_group_specific"
)
sapply(bootstrap_mean_boot_group, class)
```

## Comparison between methods
### Comparing results

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
```

```{r}
boot_to_dataframe <- function(boot, grouping_var = "Species") {
  out_df <- data.frame(
    sample = seq_len(prod(dim(boot$t))),
    Species = rep(
      levels(boot$data[[grouping_var]]),
      each = boot$R
    ),
    est_original = rep(
      boot$t0,
      each = boot$R
    ),
    rep_boot = as.vector(boot$t),
    est_boot = rep(
      apply(boot$t, 2, mean),
      each = boot$R
    ),
    se_boot = rep(
      apply(boot$t, 2, sd),
      each = boot$R
    )
  )
  out_df$bias_boot <- out_df$est_boot - out_df$est_original
  
  return(out_df)
}
```

```{r}
# Whole-cube to dataframe
bootstrap_mean_boot_whole_df <- boot_to_dataframe(bootstrap_mean_boot_whole)

# Group-specific to dataframe
bootstrap_mean_boot_group_df <- lapply(
  names(bootstrap_mean_boot_group),
  function(name) {
    boot_to_dataframe(bootstrap_mean_boot_group[[name]]) %>%
      filter(Species == name)
  }
) %>%
  bind_rows()
head(bootstrap_mean_boot_group_df)
```

Calculate confidence intervals:

```{r}
ci_mean_group <- calculate_bootstrap_ci(
  bootstrap_samples_df = bootstrap_mean_whole,
  grouping_var = "Species",
  type = c("perc", "bca", "norm", "basic"),
  conf = 0.95,
  data_cube = iris,         # Required for BCa
  fun = mean_sepal_length   # Required for BCa
) %>%
  mutate(
    method = "whole_cube",
    int_type = factor(
      int_type, levels = c("perc", "bca", "norm", "basic")
    )
  )
ci_mean_group <- calculate_bootstrap_ci(
  bootstrap_samples_df = bootstrap_mean_group,
  grouping_var = "Species",
  type = c("perc", "bca", "norm", "basic"),
  conf = 0.95,
  data_cube = iris,         # Required for BCa
  fun = mean_sepal_length   # Required for BCa
) %>%
  mutate(
    method = "group_specific",
    int_type = factor(
      int_type, levels = c("perc", "bca", "norm", "basic")
    )
  )
ci_mean_boot_whole <- calculate_bootstrap_ci(
  bootstrap_samples_df = bootstrap_mean_boot_whole,
  type = c("perc", "bca", "norm", "basic"),
  conf = 0.95
) %>%
  mutate(
    Species = rep(levels(iris$Species), each = 4),
    method = "boot_whole_cube",
    int_type = factor(
      int_type, levels = c("perc", "bca", "norm", "basic")
    )
  )
ci_mean_boot_group <- calculate_bootstrap_ci(
  bootstrap_samples_df = bootstrap_mean_boot_group,
  type = c("perc", "bca", "norm", "basic"),
  conf = 0.95
) %>%
  mutate(
    Species = rep(levels(iris$Species), each = 4),
    method = "boot_group_specific",
    int_type = factor(
      int_type, levels = c("perc", "bca", "norm", "basic")
    )
  )
```

```{r}
bootstrap_results <- bind_rows(
  bootstrap_mean_whole %>%
    mutate(method = "whole_cube"),
  bootstrap_mean_group %>%
    mutate(method = "group_specific"),
  bootstrap_mean_boot_whole_df %>%
    mutate(method = "boot_whole_cube"),
  bootstrap_mean_boot_group_df %>%
    mutate(method = "boot_group_specific")
)

# Get bias values
bias_mean_obs <- bootstrap_results %>%
  distinct(Species, estimate = est_original, `bootstrap estimate` = est_boot,
           method)

# Get estimate values
estimate_mean_obs <- bias_mean_obs %>%
  pivot_longer(cols = c("estimate", "bootstrap estimate"),
               names_to = "Legend", values_to = "value") %>%
  mutate(Legend = factor(Legend, levels = c("estimate", "bootstrap estimate"),
                         ordered = TRUE))

# Visualise
bootstrap_results %>%
  ggplot(aes(x = Species)) +
  # Distribution
  geom_violin(aes(y = rep_boot, group = Species),
              fill = alpha("cornflowerblue", 0.2)) +
  # Estimates and bias
  geom_point(data = estimate_mean_obs, aes(y = value, shape = Legend),
             colour = "firebrick", size = 2, alpha = 0.5) +
  # Intervals
  geom_errorbar(data = ci_mean_obs,
                aes(ymin = ll, ymax = ul, colour = int_type),
                position = position_dodge(0.8), linewidth = 0.8) +
  facet_wrap(~method) +
  # Settings
  labs(y = "Mean Number of Observations\nper Grid Cell",
       x = "", shape = "Legend:", colour = "Interval type:") +
  scale_x_continuous(breaks = sort(unique(bootstrap_results$year))) +
  theme_minimal() +
  theme(legend.position = "bottom",
        legend.title = element_text(face = "bold"))
```


### Comparing speed

> Under construction
