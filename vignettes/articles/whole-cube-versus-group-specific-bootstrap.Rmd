---
title: "Whole-cube Bootstrap versus Group-specific Bootstrap"
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

When calculating biodiversity indicators from a cube, we often want confidence intervals (CIs) using bootstrapping. In **dubicube**, bootstrapping can be done in two ways:

* **Whole-cube bootstrapping**: resampling all rows in the cube, regardless of grouping.
* **Group-specific bootstrapping**: resampling rows only within a group of interest (e.g., a species, year, or habitat).

The choice between these two methods directly affects how confidence intervals should be interpreted:

* Other indicators **combine information across groups** (e.g., community richness, turnover, or multi-species metrics). These require whole-cube bootstrapping to preserve correlations.
* Some indicators are **calculated independently per group** (e.g., species-specific or year-specific metrics). For these, group-specific bootstrapping is usually more appropriate.

In this tutorial, we explain the differences, discuss the strengths and limitations of each method, and provide a worked example.

## Methods

Consider the `iris` example dataset. We calculate the mean sepal length and use bootstrapping for uncertainty calculation.

```{r}
mean_sepal_length <- function(x) {
  out_df <- aggregate(Sepal.Length ~ Species, x, mean)
  names(out_df) <- c("Species", "diversity_val")
  out_df
}
```

```{r}
mean_sepal_length(iris)
```

### `dubicube`'s smart method

The smart option (`method = "smart"`) is the default functionality of the `bootstrap_cube()` function. With this option, **dubicube** automatically chooses the most suitable method. It does so by comparing indicator values calculated on larger versus smaller subsets of the data, checking whether the common groups yield identical results. If so, group-specific bootstrapping is applied; otherwise, whole-cube bootstrapping is used. If no reference group is used (`ref_group = NA`), the **boot** package is used for bootstrapping.

| Scope of indicator calculation | Reference group used? | Method chosen by `method = "smart"` | Uses **boot** package? |
| ------------------------------ | --------------------- | --------------------- | --- |
| Group-specific                 | No (`ref_group = NA`) | `boot_group_specific` | yes |
| Whole cube                     | No (`ref_group = NA`) | `boot_whole_cube`     | yes |
| Group-specific                 | Yes                   | `group_specific`      | no  |
| Whole cube                     | Yes                   | `whole_cube`          | no  |

In practice, users rarely need to set method explicitly: `method = "smart"` selects the appropriate strategy based on indicator behaviour and the presence of a reference group.

```{r}
bootstrap_mean_smart <- bootstrap_cube(
  data_cube = iris,
  fun = mean_sepal_length,
  grouping_var = "Species",
  samples = 1000,
  seed = 123,
  processed_cube = FALSE # We are not working with a processed cube
)
```

As expected, the **boot** package was used since no reference group was specified and we use group-specific bootstrapping since the mean sepal length is calculated separately per species.
We get a named list of boot objects.

```{r}
sapply(bootstrap_mean_smart, class)
```

### Whole-cube bootstrap

**Definition:** Resample all rows in the cube, regardless of species, year, or other grouping.

**Advantages:**

* Preserves correlations between groups (e.g., species co-occurrence, temporal dependencies).
* Appropriate for indicators that depend on multiple groups together (community-level metrics, multi-species diversity).

**Disadvantages:**

* Rare groups may end up with zero rows in some bootstrap replicates, leading to wider or undefined CIs.
* Variance for small groups may be inflated.

**Use case examples:**

* Community richness per site or habitat.
* Multi-species indicators (e.g., average occupancy across species).
* Temporal turnover indicators that rely on multiple years.

**Implementation in `dubicube`**

* Use `method = "whole_cube"` in the `bootstrap_cube()` function.

```{r}
bootstrap_mean_whole_cube <- bootstrap_cube(
  data_cube = iris,
  fun = mean_sepal_length,
  grouping_var = "Species",
  samples = 1000,
  seed = 123,
  processed_cube = FALSE,
  method = "whole_cube"
)
head(bootstrap_mean_whole_cube)
```

### Group-specific bootstrap

**Definition:** Subset the cube by the group of interest (e.g., species or year), then resample rows only within that group.

**Advantages:**

* Guarantees each replicate has rows for the group → stable CIs.
* Reflects within-group variability only.

**Disadvantages:**

* Ignores correlations with other groups.
* Variance may be slightly underestimated if the group’s presence is correlated with other groups.

**Use case examples:**

* Species-specific occupancy or habitat preference metrics.
* Year-specific indicators (e.g., annual richness).
* Small or rare groups where zero-row replicates would be problematic.

**Implementation in `dubicube`**

* Use `method = "group_specific"` in the `bootstrap_cube()` function.

```{r}
bootstrap_mean_group_specific <- bootstrap_cube(
  data_cube = iris,
  fun = mean_sepal_length,
  grouping_var = "Species",
  samples = 1000,
  seed = 123,
  processed_cube = FALSE,
  method = "group_specific"
)
head(bootstrap_mean_group_specific)
```

### Bootstrapping with boot

> Under construction

## Comparing performance between methods

> Under construction
