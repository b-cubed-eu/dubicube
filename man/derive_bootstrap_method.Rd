% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/derive_bootstrap_method.R
\name{derive_bootstrap_method}
\alias{derive_bootstrap_method}
\title{Derive bootstrap method for a statistic}
\usage{
derive_bootstrap_method(
  df,
  fun,
  ...,
  cat_var,
  min_cat = 2,
  max_cat = 5,
  index = -1
)
}
\arguments{
\item{df}{A dataframe.}

\item{fun}{A function which, when applied to
\code{df} returns the statistic(s) of interest. This function must return a
dataframe with a column \code{diversity_val} containing the statistic of interest.}

\item{...}{Additional arguments passed on to \code{fun}.}

\item{cat_var}{A character vector specifying the grouping variable(s) used by
\code{fun}. The function \code{fun(df, ...)} should return a row per group.}

\item{min_cat}{Integer. The minimum number of categories to include in the
"short" dataset used for comparison. Defaults to \code{2}.}

\item{max_cat}{Integer. The maximum number of categories to include in the
"long" dataset. Defaults to \code{5}.}

\item{index}{Integer. Position from which the \code{max_cat} categories will be
selected for processing. Use \code{-1} (default) use the final \code{min_cat} and
\code{max_cat} categories in the dataset.}
}
\value{
A single character string: either
\itemize{
\item \code{"group_specific"} or
\item \code{"whole_cube"}
}

indicating the appropriate bootstrapping strategy.
}
\description{
Infers whether a user-supplied indicator function (\code{fun}) behaves as a
\strong{group-specific} statistic (computed independently within each category)
or a \strong{whole-cube} statistic (requiring pooled information across all
categories).
}
\details{
The function evaluates bootstrap method by comparing the statistic computed
on two filtered subsets of the data:
\itemize{
\item \strong{Short subset}: contains \code{min_cat} consecutive categories.
\item \strong{Long subset}: contains \code{max_cat} consecutive categories.
}

Both subsets end at the same category index to ensure overlap.

The indicator function is evaluated on both subsets. If the indicator values
for the overlapping categories match exactly, the function is considered
\strong{group-specific}. Otherwise, it is assumed to require \strong{whole-cube}
bootstrapping.
}
\examples{
# 1. Calculate mean per group
sepal_length_per_species <- function(x, f) {
  out_df <- aggregate(Sepal.Length ~ Species, x, f)
  names(out_df) <- c("Species", "diversity_val") # Rename columns
  return(out_df)
}
sepal_length_per_species(iris, mean)

# The mean is calculated per species, so we expect the group-specific method
derive_bootstrap_method(
  df = iris,
  fun = sepal_length_per_species,
  cat_var = "Species",
  min_cat = 1,
  max_cat = 3,
  mean
)

# 2. Calculate indicator based on whole dataset
sepal_length_per_species2 <- function(x, f) {
  out_df <- aggregate(Sepal.Length ~ Species, x, f)
  out_df$x <- out_df$x / nrow(out_df) # new line
  names(out_df) <- c("Species", "diversity_val") # Rename columns
  return(out_df)
}
sepal_length_per_species2(iris, mean)

# Now we expect the whole-cube method
derive_bootstrap_method(
  df = iris,
  fun = sepal_length_per_species2,
  cat_var = "Species",
  min_cat = 1,
  max_cat = 3,
  mean
)
}
\seealso{
Other indicator_uncertainty: 
\code{\link{add_effect_classification}()},
\code{\link{bootstrap_cube}()},
\code{\link{bootstrap_cube_raw}()},
\code{\link{calculate_acceleration}()},
\code{\link{calculate_bootstrap_ci}()}
}
\concept{indicator_uncertainty}
